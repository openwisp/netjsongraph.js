<!DOCTYPE html>
<html lang="en">
  <head>
    <title>netjsongraph.js: WiFi Clients Graph</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="../lib/css/netjsongraph-theme.css" rel="stylesheet" />
    <link href="../lib/css/netjsongraph.css" rel="stylesheet" />
    <style>
      body, html { height: 100%; }
      body { margin: 0; }
      #container { width: 100%; height: 100vh; }

      #legend {
        position: absolute;
        top: auto;
        right: 15px;
        bottom: 15px;
        width: auto;
        height: auto;
        max-width: 250px;
        padding: 0 15px;
        background: #fbfbfb;
        border-radius: 8px;
        border: 1px solid #ccc;
        color: #6d6357;
        font-family: Arial, sans-serif;
        font-size: 14px;
        z-index: 2;
      }

      #legend h4 {
        margin: 10px 0;
        text-align: center;
      }

      #legend p {
        margin: 10px 0;
        display: flex;
        align-items: center;
      }

      #legend span {
        width: 16px;
        margin-right: 5px;
      }

      #legend span.circle {
        display: inline-block;
        border-radius: 50%;
        height: 16px;
      }

      @media only screen and (max-width: 850px) {
        #legend {
          right: 15px;
        }
      }
    </style>
  </head>
  <body>
    <div id="legend">
      <h4>Legend</h4>
      <p><span class="circle" style="background-color: #d35454;">&nbsp;</span> WiFi clients</p>
      <p><span class="circle" style="background-color: #bdc3c7;">&nbsp;</span> Mesh nodes</p>
    </div>
    <div id="container"></div>
    <script type="text/javascript">
      // Use simplified NetJSON-format data with clients/clients_count support
      const data = "../assets/data/netjsongraph-network-nodes.json";

      const graph = new NetJSONGraph(data, {
        el: "#container",
        render: "graph",
        metadata: true,
        graphConfig: {
            series: {
                force: {
                    gravity: 0.1,
                    edgeLength: [80, 100],
                    repulsion: 700,
                },
          emphasis: {
            disabled: true,
          },
                layout: "force",
                roam: true,
                label: { show: true, color: "#fff" },
            nodeStyle: { color: "#fff", opacity:"0.75" },
                linkStyle: { color: "#00ff04", width: 6 },
                nodeSize: 22,
            },
          baseOptions: {
            backgroundColor: "#222"
          }
        },
        onReady() {
          const ZOOM_THRESHOLD = 1.3;
          let clientsOverlay = null;
          let isAnimating = false; // The "lock" flag
          let roamTimer;
          const echartsInstance = this.echarts;

          const updateOverlayVisibility = () => {
            // If an animation is already running, do nothing
            if (isAnimating) {
              console.log("Animation in progress, skipping update.");
              return;
            }

            const zoom = getCurrentGraphZoom(echartsInstance);
            
            // Condition to SHOW the overlay
            if (zoom >= ZOOM_THRESHOLD && !clientsOverlay) {
              console.log("Zoom threshold reached. Attaching clients overlay.");
              isAnimating = true; // Lock
              clientsOverlay = this.attachClientsOverlay({
                radius: 4,
                gap: 2,
              });
              // Unlock after the fade-in animation completes (400ms duration)
              setTimeout(() => {
                console.log("Attach animation complete.");
                isAnimating = false;
              }, 400);
            } 
            // Condition to HIDE the overlay
            else if (zoom < ZOOM_THRESHOLD && clientsOverlay) {
              console.log("Zoom below threshold. Destroying clients overlay.");
              isAnimating = true; // Lock
              
              const overlayToDestroy = clientsOverlay;
              clientsOverlay = null; // Update state immediately

              // Pass a callback to the destroy function
              overlayToDestroy.destroy(() => {
                console.log("Destroy animation complete.");
                isAnimating = false; // Unlock
              });
            }
          };
          
          echartsInstance.on('graphRoam', () => {
            clearTimeout(roamTimer);
            roamTimer = setTimeout(() => {
              updateOverlayVisibility.call(this);
            }, 150);
          });
          
          updateOverlayVisibility.call(this);
        }
      });

      graph.render();

      function getCurrentGraphZoom(echartsInstance) {
        try {
          const option = echartsInstance.getOption();
          const series = Array.isArray(option.series) ? option.series : [];
          const graphSeries = series.find((s) => s);
          if (graphSeries && typeof graphSeries.zoom === "number") {
            return graphSeries.zoom;
          }
        } catch (e) {}
        return 1;
      }
    </script>
  </body>
  </html>

