<!DOCTYPE html>
<html lang="en">
  <head>
    <title>netjsongraph.js: basic example</title>
    <meta charset="utf-8" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css"
      integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ=="
      crossorigin=""
    />
    <!-- theme can be easily customized via css -->
    <link href="../src/css/netjsongraph-theme.css" rel="stylesheet" />
    <link href="../src/css/netjsongraph.css" rel="stylesheet" />
    <style type="text/css">
      .njg-metadata {
        left: 50px;
      }
    </style>
  </head>
  <body>
    <script type="text/javascript" src="../dist/netjsongraph.min.js"></script>
    <script type="text/javascript">
      /*
            The demo is used to show how to use the `JSONDataUpdate` function to update data.
            Here we choose to append data by modify the default parameter.
            See other examplesï¼š
            netjson-updateData.html: It chooses override data.
            netjsonmap-nodeTiles.html: override data by different zoom value.
        */
      const folderName = "./data/netjsonAppendData/",
        tilesMap = {
          4: "2.json",
        },
        map = new NetJSONGraph("./data/netjsonAppendData/1.json", {
          render: "map",
          // set map initial state.
          mapOptions: {
            center: [46.86764405052012, 19.675998687744144],
            zoom: 2,
            nodeConfig: {
              label: {
                offset: [0, -10],
              },
            },
          },

          // Convert to internal json format
          prepareData: (data) => {
            data.nodes.map((node) => {
              node.label = node.name;
              node.properties = Object.assign(node.properties || {}, {
                location: node.location,
              });
            });
          },

          onLoad: function () {
            const gui = this.utils.getGUI(this);
            gui.init();
            if (this.config.metadata) {
              gui.createAboutContainer(map);
              this.utils.updateMetadata.call(this);
            }
            if (this.config.switchMode) {
              gui.renderModeSelector.onclick = () => {
                if (this.config.render === this.utils.mapRender) {
                  this.config.render = this.utils.graphRender;
                  const canvasContainer = this.echarts
                    .getZr()
                    .painter.getViewportRoot().parentNode;
                  this.echarts.clear();
                  this.utils.graphRender(this.data, this);
                  canvasContainer.style.background =
                    // eslint-disable-next-line no-underscore-dangle
                    this.echarts.getZr()._backgroundColor;
                } else {
                  this.echarts.clear();
                  this.config.render = this.utils.mapRender;
                  this.utils.mapRender(this.data, this);
                }
              };
            }
            this.config.onClickElement = (type, data) => {
              let nodeLinkData;
              if (type === "node") {
                nodeLinkData = this.utils.nodeInfo(data);
              } else {
                nodeLinkData = this.utils.linkInfo(data);
              }
              gui.getNodeLinkInfo(type, nodeLinkData);
              gui.sideBar.classList.remove("hidden");
            };
            /* 
                        The map has this property only after the map is rendered, 
                        so we have to put the relevant function in `onLoad` life cycle  
                    */
            let baseMap = this.leaflet,
              preZoom = this.config.mapZoom;

            /*
                        Monitor the zoom of the leaflet.
                        New data is updated if the zoom value reaches the relevant threshold.
                    */
            baseMap.on("zoomstart", () => {
              preZoom = baseMap.getZoom();
            });
            baseMap.on("zoomend", () => {
              let curZoom = baseMap.getZoom();
              if (preZoom !== curZoom && tilesMap[curZoom]) {
                // append data function
                this.utils.JSONDataUpdate.call(
                  this,
                  folderName + tilesMap[curZoom],
                  false,
                );

                Reflect.deleteProperty(tilesMap, curZoom);
              }
            });

            this.utils.hideLoading();
          },
        });

      map.render();
    </script>
  </body>
</html>
