<!DOCTYPE html>
<html lang="en">
  <head>
    <title>netjsongraph.js: basic example</title>
    <meta charset="utf-8" />
    <!-- theme can be easily customized via css -->
    <link href="../src/css/netjsongraph-theme.css" rel="stylesheet" />
    <link href="../src/css/netjsongraph.css" rel="stylesheet" />
  </head>
  <body>
    <script type="text/javascript" src="../dist/netjsongraph.min.js"></script>
    <script type="text/javascript">
      /*
            The demo is used to show hwo to interact with elements.
        */
      // `graph` render defaultly.
      const graph = new NetJSONGraph("./data/netjsongraph-foldNodes.json", {
        dealDataByWorker: "../src/js/netjsonWorker.js",
        echartsOption: {
          legend: {
            left: 10,
            bottom: 10,
            orient: "vertical",
            textStyle: {
              color: "#6d6357",
              fontFamily: "Arial, sans-serif",
              fontSize: 14,
            },
            backgroundColor: "#fbfbfb",
            borderWidth: 1,
            borderRadius: 2,
          },
        },

        // Convert to internal json format
        prepareData: (data) => {
          data.nodes.map((node) => {
            node.properties = Object.assign(node.properties || {}, {
              category: node.category,
            });
          });
        },

        onLoad: function () {
          const gui = this.utils.getGUI(this);
          gui.init();
          if (this.config.metadata) {
            gui.createAboutContainer(graph);
            this.utils.updateMetadata.call(this);
          }
          if (this.config.switchMode) {
            gui.renderModeSelector.onclick = () => {
              if (this.config.render === this.utils.mapRender) {
                this.config.render = this.utils.graphRender;
                this.echarts.dispose();
                graph = new NetJSONGraph(this.data, {
                  ...this.config,
                });
                graph.render();
              } else {
                this.config.render = this.utils.mapRender;
                this.config.render(this.data, this);
              }
            };
          }
          this.config.onClickElement = (type, data) => {
            let nodeLinkData;
            if (type === "node") {
              nodeLinkData = this.utils.nodeInfo(data);
            } else {
              nodeLinkData = this.utils.linkInfo(data);
            }
            gui.getNodeLinkInfo(type, nodeLinkData);
            clickElement.call(this, type, data);
            gui.sideBar.classList.remove("hidden");
          };
          this.utils.hideLoading();
        },
      });

      graph.render();

      function clickElement(type, data) {
        // expand or fold nodes
        if (type === "node" && data.childNodes) {
          let JSONData = this.data;

          // Detect whether expanded.
          if (!data._expanded) {
            // Traverse child nodes, add them to the level with father.
            data.childNodes.map((child) => {
              // The `flatNodes` attribute is obtained after processed by `dealDataByWorker`.
              JSONData.flatNodes[child.id] = child;
              JSONData.nodes.push(child);
              // Add links
              JSONData.links.push({
                source: data.id,
                target: child.id,
              });
              child.category = data.category;
            });

            JSONData.flatNodes[data.id]._expanded = true;
          } else {
            // delete expanded nodes
            data.childNodes.map((child) => {
              let node = JSONData.flatNodes[child.id],
                index = JSONData.nodes.indexOf(node);

              JSONData.nodes.splice(index, 1);
              Reflect.deleteProperty(JSONData.flatNodes, child.id);
            });

            JSONData.flatNodes[data.id]._expanded = false;
          }

          graph.echarts.setOption(
            graph.utils.generateGraphOption(JSONData, graph),
          );
        }
      }
    </script>
  </body>
</html>
