const operations={addFlatNodes(e){const o={},s={};return e.forEach((e=>{o[e.id]=e,e.local_addresses&&e.local_addresses.forEach((o=>{s[o]=e}))})),{flatNodes:o,nodeInterfaces:s}},addNodeLinks(e){const o={},s=[];return e.links.forEach((s=>{const t=e.flatNodes[s.source],a=e.flatNodes[s.target];if(t&&a){if(t.id===a.id)return void console.error(`Link source and target (${t.id}) are duplicated!`);o[t.id]||(o[t.id]=0),o[a.id]||(o[a.id]=0),o[t.id]+=1,o[a.id]+=1}else t?console.error(`Node ${s.target} does not exist!`):console.error(`Node ${s.source} does not exist!`)})),Object.keys(e.flatNodes).forEach((t=>{const a=e.flatNodes[t];a.linkCount=o[t]||0,s.push(a)})),s},changeInterfaceID(e){const o=JSON.parse(JSON.stringify(e.links));for(let s=o.length-1;s>=0;s-=1){const t=o[s];t.source&&t.target&&(e.nodeInterfaces[t.source]&&(t.source=e.nodeInterfaces[t.source].id),e.nodeInterfaces[t.target]&&(t.target=e.nodeInterfaces[t.target].id),t.source===t.target&&o.splice(s,1))}return o},arrayDeduplication(e,o=[],s=!0){const t=JSON.parse(JSON.stringify(e)),a=[];for(let e=t.length-1;e>=0;e-=1){const n=[];let d=0;for(const s of o){if(!t[e][s]){console.error(`The array doesn't have "${s}"`),d=1;break}n.push(t[e][s])}if(d)t.splice(e,1);else{const o=s?n.join(""):n.sort().join("");-1!==a.indexOf(o)?t.splice(e,1):a.push(o)}}return t},deduplicateNodesById(e){const o=[],s=new Set;return e.forEach((e=>{e.id?s.has(e.id)?console.warn(`Duplicate node ID detected and skipped: ${e.id}`):(s.add(e.id),o.push(e)):o.push(e)})),o}};function dealJSONData(e){e.nodes||(e.nodes=[]),e.nodes=operations.deduplicateNodesById(e.nodes);const{flatNodes:o,nodeInterfaces:s}=operations.addFlatNodes(e.nodes);return e.flatNodes=o,e.nodeInterfaces=s,e.links||(e.links=[]),e.links=operations.changeInterfaceID(e),e.links=operations.arrayDeduplication(e.links,["source","target"],!1),e.nodes=operations.addNodeLinks(e),e}self.addEventListener("message",(e=>{dealJSONData(e.data,operations),postMessage(e.data),close()})),module.exports={operations,dealJSONData};